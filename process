processTable = {}
list = {}
focusWindow = nil
activeProcess = nil
windowCompositor = {}
redirectStack = {}
nullRedirect = framebuffer.new()
eventHooks = {}
local id = 1

local oldTredirect = term.redirect
local oldTrestore = term.restore

local function newTredirect(target)
	if term.current then
		table.insert(process.redirectStack, target)
		return oldTredirect(target)
	else
		oldTrestore()
		table.insert(process.redirectStack, target)
		oldTredirect(target)
	end
end

local function newTrestore()
	if #process.redirectStack > 1 then
		if term.current then
			oldTredirect(table.remove(process.redirectStack))
		else
			oldTrestore()
			table.remove(process.redirectStack)
			oldTredirect(process.redirectStack[#process.redirectStack])
		end
	end
end

function resume(pID, event)
	if process.list[pID] then
		return process.list[pID]:resume(event)
	end
end

function resume(pID, eventTable)
	--evaluate whether this event should even go to this process.
	if process.processTable[pID].listening then
		local resumeProcess = false
		for i=1, #process.processTable[pID].listening do
			if eventTable[1] == process.processTable[pID].listening[i] then
				resumeProcess = true
				process.processTable[pID].listening = nil
				break
			end
		end
		if not resumeProcess then return unpack(eventTable) end
	end

	--redirect to window's current position in its redirect stack
	local _old = term.redirect(process.processTable[pID].redirect[#process.processTable[pID].redirect])

	--copy redirect stack to global table
	process.redirectStack = {}
	for i = 1, #process.processTable[pID].redirect do
		process.redirectStack[i] = process.processTable[pID].redirect[i]
	end

	rawset(term, "redirect", newTredirect)
	rawset(term, "restore", newTrestore)

	local active = process.activeProcess
	process.activeProcess = pID
	passback = {coroutine.resume(process.processTable[pID].thread, unpack(eventTable))}
	process.windowCompositor:draw()
	process.activeProcess = active
	--if the process had a window, recover its redirect stack and restore the redirect functions.
	if process.processTable[pID] then

		--restore correct redirection level and save redirect stack for resume.
		rawset(term, "redirect", oldTredirect)
		rawset(term, "restore", oldTrestore)

		process.processTable[pID].redirect = {}
		for i=1, #process.redirectStack do
			process.processTable[pID].redirect[i] = process.redirectStack[i]
		end
		if _old then
			term.redirect(_old)
		else
			term.restore()
		end

		--handle filters being sent back in passback.
		if passback[1] and passback[2] then
			if type(passback[2]) == "string" then
				process.processTable[pID].listening = {passback[2]}
			elseif type(passback[2]) == "table" then
				process.processTable[pID].listening = passback[2]
			end
		end
	end
	--former checkProcess function.
	if not process.list[pID]:check() then
		if not process.processTable[pID].window then
			process.remove(pID)
		end
	end
	return unpack(passback, 2)
end

function add(func, path, win, redirect)
	local pTable = {}
	pTable.thread = coroutine.create(func)
	pTable.path = path
	pTable.queue = {}
	table.insert(process.processTable, pTable)
	if win then
		pTable.window = win
		pTable.redirect = {win.redirect}
		process.focusWindow = #process.processTable
	elseif redirect then
		pTable.redirect = {redirect}
	else
		pTable.redirect = {process.nullRedirect}
	end
	process.resume(#process.processTable, {})
end

function remove(pID)
	process.processTable[pID] = false
	if pID == process.focusWindow then
		process.focusWindow = process.nextWindow()
		if process.focusWindow then
			process.list[process.focusWindow]:toFront()
		end
	end
end

function kill(pID)
	if process.processTable[pID] then
		if process.processTable[pID].window then
			process.processTable[pID].window:destroy()
		end
		process.remove(pID)
		return true
	end
	return false
end

local function tablify(baseTable, keyTable)
	if #keyTable > 1 then
		local key = table.remove(keyTable, 1)
		if not baseTable[key] then
			baseTable[key] = {}
		elseif type(baseTable[key]) ~= "table" then
			return false
		end
		return tablify(baseTable[key], keyTable)
	elseif #keyTable == 1 then
		return baseTable, keyTable[1]
	end
end

function changeHookActual(hookMask, val)
	local ref, key = tablify(process.eventHooks, hookMask)
	if ref and (not val or not ref[key]) then
		ref[key] = val
	else
		return false
	end
end

function addHook(hookMask)
	return changeHookActual(hookMask, process.id())
end

function removeHook(hookMask)
	return changeHookActual(hookMask)
end

function setFocus(num)
	focusWindow = num
end

function addChildWindow(pID, childWindow)
	if process.processTable[pID].children then
		local isChild = false
		for k, v in ipairs(process.processTable[pID].children) do
			if v == childWindow then
				isChild = true
				break
			end
		end
		if not isChild then
			table.insert(process.processTable[pID].children, 1, childWindow)
		end
	else
		process.processTable[pID].children = {childWindow, "rootWindow"}
	end
end

function removeChildWindow(pID, childWindow)
	if processTable[pID] and processTable[pID].children then
		local index
		for k, v in ipairs(processTable[pID].children) do
			if v == childWindow then
				index = k
				break
			end
		end
		if index then
			table.remove(processTable[pID].children, index)
		end
	end
end

function getWindow()
	if process.activeProcess and process.processTable[process.activeProcess] and process.processTable[process.activeProcess].window then
		return process.processTable[process.activeProcess].window
	else
		return nil, "No window!"
	end
end

function setWindowProperty(window, parameters)
	if type(window) == "string" then
		--table.insert()
	elseif type(window) == "table" then
		for k, v in pairs(parameters) do
			if window[k] then
				window[k] = v
			end
		end
	end
end

function queueEvent(pID, ...)
	if process.processTable[pID] and process.processTable[pID].queue then
		table.insert(process.processTable[pID].queue, {...})
		return true
	else
		return false
	end
end

function nextWindow(default)
	if process.processTable[process.focusWindow] and process.processTable[process.focusWindow].parent then
		if process.processTable[process.processTable[process.focusWindow].parent] and process.processTable[process.processTable[process.focusWindow].parent].window then
			return process.processTable[process.focusWindow].parent
		end
	else
		local nextBuf = process.windowCompositor.bufferStack[#process.windowCompositor.bufferStack]
		local nextActive = default
		for tNum, tInfo in ipairs(process.processTable) do
			if tInfo and tInfo.window then
				if tInfo.window.target.buffer == nextBuf then
					nextActive = tNum
				end
			end
		end
		return nextActive
	end
end

function id()
	if process.activeProcess and process.processTable[process.activeProcess] then
		return process.activeProcess
	else
		return nil, "No active process!"
	end
end

function getFromPath(path)
	for pID, proc in ipairs(process.list) do
		if proc and proc.path == path then
			return proc
		end
	end
end

function getFromName(name)
	for pID, proc in ipairs(process.list) do
		if proc and proc.name == name then
			return proc
		end
	end
end

local Process = {
	resume = function(self, event)
		--evaluate whether this event should even go to this process.
		if self.listening then
			local resumeProcess = false
			for i=1, #self.listening do
				if eventTable[1] == self.listening[i] then
					resumeProcess = true
					self.listening = nil
					break
				end
			end
			if not resumeProcess then return unpack(eventTable) end
		end

		--redirect to window's current position in its redirect stack
		local _old = term.redirect(self.redirect[#self.redirect])

		--copy redirect stack to global table
		process.redirectStack = {}
		for i = 1, #self.redirect do
			process.redirectStack[i] = self.redirect[i]
		end

		rawset(term, "redirect", newTredirect)
		rawset(term, "restore", newTrestore)

		local active = process.activeProcess
		process.activeProcess = self.id
		passback = {coroutine.resume(self.thread, unpack(eventTable))}
		process.windowCompositor:draw()
		process.activeProcess = active

		--restore correct redirection level and save redirect stack for resume.
		rawset(term, "redirect", oldTredirect)
		rawset(term, "restore", oldTrestore)

		self.redirect = {}
		for i=1, #process.redirectStack do
			self.redirect[i] = process.redirectStack[i]
		end
		if _old then
			term.redirect(_old)
		else
			term.restore()
		end

		--handle filters being sent back in passback.
		if passback[1] and passback[2] then
			if type(passback[2]) == "string" then
				self.listening = {passback[2]}
			elseif type(passback[2]) == "table" then
				self.listening = passback[2]
			end
		end

		--former checkProcess function.
		if not self:check() then
			if not self.window then
				self:remove()
			end
		end
		return unpack(passback, 2)
	end,
	check = function(self)
		local proc = process.processTable[pID]
		if coroutine.status(self.thread) == "dead" or (self.special and self.id ~= process.focusWindow) then
			if self.window then
				if self.path == "desktop" then
					--send terminate signal; pcall wrappers will allow current windows to close without killing process.
					self:queue("terminate")
				else
					process.getFromName("lws"):queue("close_window", pID)
				end
			end
			return false
		end
		return true
	end,
	queue = function(self, ...)
		table.insert(self.queue, {...})
		return true
	end,
	kill = function(self)
		if self.window then
			self.window:destroy()
		end
		self:remove()
		return true
	end,
	remove = function(self)
		process.list[self.id] = false
		if self.id == process.focusWindow then
			process.focusWindow = process.nextWindow()
			if process.focusWindow then
				process.list[process.focusWindow]:toFront()
			end
		end
	end,
	addWindow = function(self, win)
		local newWindow = true
		for i = 1, #self.windows do
			if self.windows[i] == win then
				newWindow = false
				break
			end
		end
		if newWindow then
			table.insert(self.windows, win)
		end
	end,
	removeWindow = function(self, win)
		local winFound = false
		for i = 1, #self.windows do
			if self.windows[i] == win then
				table.remove(self.windows, i)
				winFound = true
				break
			end
		end
		if winFound then
			win:destroy()
		end
	end,
	toFront = function(self, win)
		--win is optional, if not specified will maintain order of windows.
		if win then
			for i = 1, #self.windows do
				if self.windows[i] == win then
					table.insert(self.windows, table.remove(self.windows, i))
					break
				end
			end
		end
		for i = 1, #self.windows do
			for j = 1, #process.windowCompositor.bufferStack do
				if process.windowCompositor.bufferStack[j] == self.windows[i].target.buffer then
					process.windowCompositor:toFront(j)
					break
				end
			end
		end
	end,
	toBack = function(self, win)
		--win is optional, will move that window to behind the rest of them, as well as moving the whole set to the bottom of the stack.
		if win then
			for i = 1, #self.windows do
				if self.windows[i] == win then
					table.insert(self.windows, 1, table.remove(self.windows, i))
					break
				end
			end
		end
		local lookup, buffStackLookup = {}, {}
		for i = 1, #self.windows do
			lookup[self.windows[i]] = i
		end
		for i = 1, #process.windowCompositor.bufferStack do
			if lookup[process.windowCompositor.bufferStack[i]] then
				buffStackLookup[process.windowCompositor.bufferStack[i]] = i
			end
		end
		for win, index in pairs(lookup) do
			table.insert(process.windowCompositor.bufferStack, index + 1, table.remove(process.windowCompositor.bufferStack, bufferStackLookup[win]))
		end
		process.focusWindow = nextWindow(1)
		if process.list[process.focusWindow] then
			process.list[process.focusWindow]:toFront()
		end
	end,
}

local pmeta = {__index = Process}

function new(func, path, win, redirect)
	local proc = {
		thread = coroutine.create(func),
		path = path,
		name = fs.getName(path),
		queue = {},
		id = id,
		windows = {},
	}

	table.insert(process.list, proc)

	if win then
		table.insert(proc.windows, win)
		proc.redirect = {win.redirect}
		process.focusWindow = #process.list
	elseif redirect then
		proc.redirect = {redirect}
	else
		proc.redirect = {process.nullRedirect}
	end
	
	setmetatable(proc, pmeta)

	proc:resume({})
	return proc
end