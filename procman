if process and process.activeProcess ~= nil then return end

local path

do
	--current path discovery, set up shell paths.
	local procPath = shell.getRunningProgram()
	path = fs.getDir and fs.getDir(procPath) or string.match(procPath, "^(.*)/"..fs.getName(procPath).."$")
	shell.setPath("/"..path..":"..shell.path())
	if fs.exists("/usr/apis") and fs.isDir("/usr/apis") then shell.setPath(shell.path()..":/usr/apis") end
end

if not framebuffer then if shell.resolveProgram("framebuffer") and fs.exists(shell.resolveProgram("framebuffer")) then if not os.loadAPI(shell.resolveProgram("framebuffer")) then print("Could not load framebuffer API!") return end else print("Could not find framebuffer API!") return end end
if not compositor then if shell.resolveProgram("compositor") and fs.exists(shell.resolveProgram("compositor")) then if not os.loadAPI(shell.resolveProgram("compositor")) then print("Could not load compositor API!") return end else print("Could not find compositor API!") return end end
if not menu then if shell.resolveProgram("menu") and fs.exists(shell.resolveProgram("menu")) then if not os.loadAPI(shell.resolveProgram("menu")) then print("Could not load menu API!") return end else print("Could not find menu API!") return end end
if not process then if shell.resolveProgram("process") and fs.exists(shell.resolveProgram("process")) then if not os.loadAPI(shell.resolveProgram("process")) then print("Could not load process API!") return end else print("Could not find process API!") return end end
if window and window.create then os.unloadAPI("window") end --kill 1.6 window API.
if not window then if shell.resolveProgram("window") and fs.exists(shell.resolveProgram("window")) then if not os.loadAPI(shell.resolveProgram("window")) then print("Could not load window API!") return end else print("Could not find window API!") return end end
if not metadata then if shell.resolveProgram("metadata") and fs.exists(shell.resolveProgram("metadata")) then if not os.loadAPI(shell.resolveProgram("metadata")) then print("Could not load metadata API!") return end else print("Could not find metadata API!") return end end

--establish this before loading the environment
_G.LyqydOS = {
	window = {
		theme = term.isColor() and "pretty" or "standard",
	},
	desktop = {
		background = colors.lightBlue,
		backgroundImage = "",
		theme = term.isColor() and "pretty" or "standard",
	},
	shell = {
		shell = shell,
		multishell = multishell,
	},
}

--set up environment.
dofile(shell.resolveProgram("env"))
if fs.exists(fs.combine(path, "metafs")) then
	dofile(fs.combine(path, "metafs"))
end

if fs.exists(fs.combine(path, "themes/window")) and fs.isDir(fs.combine(path, "themes/window")) then
	for _, name in pairs(fs.list(fs.combine(path, "themes/window"))) do
		local file = fs.combine(fs.combine(path, "themes/window"), name)
		local env = {}
		local fn, err = loadfile(file)
		if fn then
			setfenv(fn, env)
			fn()
			--copy into window themes
			window.themes[name] = {}
			for k, v in pairs(env) do
				window.themes[name][k] = v
			end
		end
	end
end

if fs.exists(fs.combine(path, ".config")) then
	dofile(fs.combine(path, ".config"))
end

process.focusWindow = nil
windowCompositor = compositor.new(term.current and term.current() or term.native)
windowCompositor.deferDraw = true
rawset(process, "windowCompositor", windowCompositor)

do
	local x, y = term.getSize()
	process.nullRedirect = framebuffer.new(x, y, term.isColor())
end

do
	local initPath = ""
	if fs.exists(fs.combine(path, ".init")) then
		initPath = fs.combine(path, ".init")
	else
		initPath = shell.resolveProgram(".init")
	end
	if #initPath > 0 then
		local handle = io.open(initPath, "r")
		if handle then
			for line in handle:lines() do
				process.new(function() return shell.run(line) end, shell.resolveProgram(string.match(line, "^(%S*)")))
			end
			handle:close()
		end
	end
end

local function findHook(event)
	local ref = process.eventHooks
	for i = 1, #event do
		if ref[event[i]] then
			if type(ref[event[i]]) == "table" then
				ref = ref[event[i]]
			elseif type(ref[event[i]]) == "number" then
				return ref[event[i]]
			else
				return false
			end
		else
			return false
		end
	end
end

local function distributeEvent(event)
	if process.list[process.focusWindow] then
		process.list[process.focusWindow]:resume(event)
	elseif event[1] == "key" or event[1] == "char" then
		if process.eventHooks.redraw then
			--events should fall through to desktop if there is no focus window.
			local pID = findHook({"redraw"})
			if pID and process.list[pID] then
				process.list[pID]:resume(event)
			end
		end
	end
	--handle background processes.
	if event[1] ~= "key" and event[1] ~= "char" and event[1] ~= "mouse_click" and event[1] ~= "mouse_drag" and event[1] ~= "mouse_scroll" and event[1] ~= "window_resize" and event[1] ~= "terminate" then
		for pID, proc in ipairs(process.list) do
			if pID ~= process.focusWindow and proc then
				proc:resume(event)
			end
		end
	end
end

--causes initial desktop and title bar to draw, if present.
windowCompositor:draw()

while true do
	--process individually-queued events.
	for pID, proc in pairs(process.list) do
		if proc then
			proc:check()
			if #proc.eventQueue >= 1 then
				repeat
					proc:resume(table.remove(proc.eventQueue, 1))
				until #proc.eventQueue == 0
			end
		end
	end
	--build title bar items if a desktop is present.
	if process.eventHooks.redraw then
		local pID = findHook({"redraw"})
		if pID and process.list[pID] then
			process.list[pID]:resume({"redraw"})
		end
	end

	local event = {coroutine.yield()}

	--process event hooks, like lws and desktop use for hotkeys.
	if process.eventHooks[event[1]] then
		local pID = findHook(event)
		if pID and process.list[pID] then
			event = {process.list[pID]:resume(event)}
		end
	end

	if #event > 0 then
		distributeEvent(event)
	end
end
